#!/usr/bin/env zsh

# Insert a list of selected files with fzf.
#
# If there is no parameter under the cursor, the files selected via *.
#
# If a parameter is below the cursor,
# it will be expanded and then used as a file list.
# If the cursor is at the end of the parameter * will be added before.
#
# The default pattern matches all files not recursively,
# but glob qualifier can be configured as
#
#   # directory only (e.g. *(/))
#   zstyle :jln-fzf-files glob-qualifiers '/'
#
#   # recursive search (use **/* instead of *)
#   zstyle :jln-fzf-files recursive-directory 1
#
# The default selector (jln-fzf-color-selector) uses fzf and ls for the color.
# The jln-fzf-selector does not use ls.
# The jln-fzf-size-selector use ls to display file sizes.
#
#   # reverse order for jln-fzf-size-selector and jln-fzf-color-selector
#   zstyle :jln-fzf-files ls-params -r
#
#   # case-insensitive match for fzf
#   zstyle :jln-fzf-files fzf-params -i
#
# If the files are expanded using a parameter under the cursor,
# a prefix can be added to the fzf query.
# The prefix search is rudimentary and
# may be truncated if it contains '?*<({['.
#
#   # add prefix in fzf query
#   zstyle :jln-fzf-files insert-prefix 1
#
# If needed, you can specify your own function.
# $prefix and $files will be predefined variables.
# The final string must be put in the variable REPLY.
#
#   zstyle :jln-fzf-files selector my-selector-function
#
# Note also that the style is looked up based on the widget name, so you
# can bind this function to different widgets to use different patterns:
#
#   zle -N fzf-directories jln-fzf-files
#   zstyle :fzf-directories glob-qualifiers '/'
#   bindkey '\e=' fzf-directories

emulate -L zsh -o extendedglob

jln-fzf-selector() {
  if [[ -n $prefix ]]; then
    REPLY=${(j: :)${(qf)"$(fzf -m +s $=fzf_params -q $prefix <<<${(F)files})"}}
  else
    REPLY=${(j: :)${(qf)"$(fzf -m +s $=fzf_params <<<${(F)files})"}}
  fi
}

jln-fzf-color-selector() {
  if [[ -n $prefix ]]; then
    REPLY=${(j: :)${(qf)"$(command ls $=ls_params -1d --color -- $files | fzf -m --ansi +s $=fzf_params -q $prefix)"}}
  else
    REPLY=${(j: :)${(qf)"$(command ls $=ls_params -1d --color -- $files | fzf -m --ansi +s $=fzf_params)"}}
  fi
}

jln-fzf-size-selector() {
  if [[ -n $prefix ]]; then
    REPLY=("${(f)$(command ls -Ssh $=ls_params -d1 --color -- $files | fzf -m --ansi +s $=fzf_params -q $prefix)}")
  else
    REPLY=("${(f)$(command ls -Ssh $=ls_params -d1 --color -- $files | fzf -m --ansi +s $=fzf_params)}")
  fi &&
  REPLY=${(j: :)${(q)REPLY/(#s)[ ]#[^ ]# /}}
}

local REPLY glob_qualifiers recursive_directory selector ls_params fzf_params insert_prefix
local -a files prefix

zstyle -s :$WIDGET glob-qualifiers glob_qualifiers
zstyle -s :$WIDGET recursive-directory recursive_directory
zstyle -s :$WIDGET selector selector
zstyle -s :$WIDGET ls-params ls_params
zstyle -s :$WIDGET fzf-params fzf_params
selector=${selector:-jln-fzf-color-selector}

local -i start_cursor_param=${#LBUFFER%%${${(Z:n:)LBUFFER}[-1]}}

# no parameter under the cursor
if (( start_cursor_param == CURSOR )) && [[ $BUFFER[$CURSOR+1] != [^[:space:]] ]]; then
  if [[ $recursive_directory == 1 ]]; then
    files=(**/*(N$glob_qualifiers))
  else
    files=(*(N$glob_qualifiers))
  fi

  if (( $#files == 0 )); then
    zle -M 'No matches found.'
    return 1
  fi

  $selector && LBUFFER+=$REPLY

# expand parameter under the cursor
else
  files=(${(Z:n:)${BUFFER:$start_cursor_param}})
  local word=$files[1] glob
  local -i nword=$#word

  # if positioned at the end of the parameter
  if (( $start_cursor_param + $#word == $CURSOR )); then
    # if does not end with globbing, insert *
    if [[ $word[-1] != ['?*>)'] ]] \
    || ( [[ $word[-1] == ['?*)'] ]] && (( ($#word - ${#word%%'\'#['?*)']}) % 2 == 0 )) ) \
    || ( [[ $word[-2] == '\' && $word[-1] == '>' ]] )
    then
      if [[ $recursive_directory == 1 ]]; then
        glob='**/*'
      else
        glob='*'
      fi
    fi
  fi

  eval files="($word$glob(N$glob_qualifiers))"

  if (( $#files == 0 )); then
    # if positioned in a parameter, insert * then retry
    if (( $start_cursor_param + $#word != $CURSOR )); then
      if [[ $recursive_directory == 1 ]]; then
        glob='**/*'
      else
        glob='*'
      fi
      eval files="(${word:0:$CURSOR-$start_cursor_param}*${word:$CURSOR-$start_cursor_param}$glob(N$glob_qualifiers))"
    fi

    if (( $#files == 0 )); then
      zle -M 'No matches found.'
      return 1
    fi
  fi

  zstyle -s :$WIDGET insert-prefix insert_prefix

  if [[ $insert_prefix == 1 ]]; then
    # extract left chars
    prefix=${(Q)BUFFER:$start_cursor_param:$((CURSOR-start_cursor_param))}
    # remove characters if there is a pattern
    prefix=${prefix/[?*<]*/}
    # not a prefix
    if [[ $files[1] != $prefix* ]]; then
      # remove characters if there is a glob qualifier
      prefix=${prefix/[\(\{]*/}
      # not a prefix
      if [[ $files[1] != $prefix* ]]; then
        # remove characters if there is a group pattern
        prefix=${prefix/[\[]*/}
        # not a prefix => reset prefix
        if [[ $files[1] != $prefix* ]]; then
          prefix=
        fi
      fi
    fi
  fi

  if $selector ; then
    if ((CURSOR != start_cursor_param)); then
      RBUFFER=${RBUFFER:$((nword-CURSOR+start_cursor_param))}
    fi
    LBUFFER=${LBUFFER:0:$start_cursor_param}$REPLY
  fi
fi

zle redisplay
